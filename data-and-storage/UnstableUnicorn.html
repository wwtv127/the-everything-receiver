<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unstable Unicorns - Multiplayer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Lobby Styles */
        .lobby {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            max-width: 500px;
            margin: 50px auto;
        }

        .lobby h1 {
            color: #764ba2;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .lobby-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
        }

        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.1em;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        input[type="text"] {
            width: 100%;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 1.1em;
            text-align: center;
            margin-bottom: 15px;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #764ba2;
        }

        .room-info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .room-code {
            font-size: 2em;
            font-weight: bold;
            color: #764ba2;
            text-align: center;
            margin: 10px 0;
            letter-spacing: 5px;
        }

        .players-list {
            margin-top: 20px;
        }

        .players-list h3 {
            color: #555;
            margin-bottom: 10px;
        }

        .player-item {
            background: white;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-item.host::after {
            content: "HOST";
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 5px;
            font-size: 0.8em;
        }

        .player-item.current {
            background: #d1f2eb;
            font-weight: bold;
        }

        /* Game Board Styles */
        .game-board {
            display: none;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
        }

        .game-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .turn-indicator {
            font-size: 1.2em;
            font-weight: bold;
        }

        .phase-indicator {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 15px;
            border-radius: 5px;
        }

        .my-turn-indicator {
            background: #28a745;
            color: white;
            padding: 5px 15px;
            border-radius: 5px;
            font-weight: bold;
        }

        .not-my-turn {
            background: #dc3545;
        }

        .game-area {
            display: grid;
            grid-template-columns: 200px 1fr 200px;
            gap: 20px;
        }

        .deck-area {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
        }

        .deck {
            background: #333;
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            margin-bottom: 10px;
            transition: transform 0.2s;
        }

        .deck:hover {
            transform: scale(1.05);
        }

        .deck.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .deck.disabled:hover {
            transform: none;
        }

        .discard-pile {
            background: #6c757d;
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            min-height: 100px;
        }

        .main-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .opponents-area {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .opponent-stable {
            background: #e9ecef;
            border-radius: 10px;
            padding: 15px;
            min-width: 200px;
            flex: 1;
        }

        .opponent-stable.current-player {
            border: 3px solid #28a745;
        }

        .stable-header {
            font-weight: bold;
            margin-bottom: 10px;
            color: #495057;
        }

        .my-stable {
            background: #d1f2eb;
            border-radius: 10px;
            padding: 20px;
            min-height: 200px;
        }

        .my-stable.current-player {
            border: 3px solid #28a745;
        }

        .my-hand {
            background: #fff3cd;
            border-radius: 10px;
            padding: 20px;
        }

        .hand-cards {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .card {
            background: white;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 10px;
            width: 120px;
            min-height: 160px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        .card.selected {
            border-color: #28a745;
            border-width: 3px;
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.5);
        }

        .card-type {
            font-size: 0.7em;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .card-name {
            font-weight: bold;
            font-size: 0.9em;
            margin-bottom: 5px;
            color: #333;
        }

        .card-description {
            font-size: 0.7em;
            color: #555;
            flex-grow: 1;
        }

        .card.unicorn {
            background: linear-gradient(135deg, #ffeaa7 0%, #fdcb6e 100%);
        }

        .card.magic {
            background: linear-gradient(135deg, #a29bfe 0%, #6c5ce7 100%);
            color: white;
        }

        .card.magic .card-type,
        .card.magic .card-description {
            color: #ddd;
        }

        .card.instant {
            background: linear-gradient(135deg, #fd79a8 0%, #e84393 100%);
            color: white;
        }

        .card.instant .card-type,
        .card.instant .card-description {
            color: #ddd;
        }

        .card.upgrade {
            background: linear-gradient(135deg, #55efc4 0%, #00b894 100%);
        }

        .card.downgrade {
            background: linear-gradient(135deg, #fab1a0 0%, #e17055 100%);
        }

        .card.baby {
            background: linear-gradient(135deg, #81ecec 0%, #74b9ff 100%);
        }

        .stable-cards {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            min-height: 100px;
        }

        .action-buttons {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .action-button {
            padding: 10px 20px;
            font-size: 0.9em;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal h2 {
            color: #764ba2;
            margin-bottom: 20px;
        }

        .target-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .target-option {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .target-option:hover {
            border-color: #764ba2;
            background: #f8f9fa;
        }

        .game-log {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 5px;
            border-bottom: 1px solid #dee2e6;
            font-size: 0.9em;
        }

        .log-entry.error {
            color: #dc3545;
            font-weight: bold;
        }

        .win-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            z-index: 2000;
        }

        .win-screen h1 {
            color: #28a745;
            font-size: 3em;
            margin-bottom: 20px;
        }

        .status-message {
            background: #ffc107;
            color: #000;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .game-area {
                grid-template-columns: 1fr;
            }

            .card {
                width: 100px;
                min-height: 140px;
            }
            
            .action-buttons {
                bottom: 10px;
                right: 10px;
                left: 10px;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Lobby Screen -->
        <div id="lobby" class="lobby">
            <h1>ðŸ¦„ Unstable Unicorns</h1>
            
            <div id="initial-menu">
                <div class="lobby-buttons">
                    <button onclick="createRoom()">Create Room</button>
                    <button onclick="showJoinRoom()">Join Room</button>
                </div>
            </div>

            <div id="join-room" style="display: none;">
                <h2>Join Room</h2>
                <input type="text" id="room-code-input" placeholder="Enter 5-digit room code" maxlength="5">
                <input type="text" id="player-name-input" placeholder="Enter your name">
                <button onclick="joinRoom()">Join</button>
                <button onclick="backToMenu()">Back</button>
            </div>

            <div id="room-lobby" style="display: none;">
                <div class="room-info">
                    <h2>Room Code:</h2>
                    <div class="room-code" id="room-code-display"></div>
                    
                    <div class="players-list">
                        <h3>Players:</h3>
                        <div id="players-list"></div>
                    </div>
                    
                    <button id="start-game-btn" onclick="startGame()" style="display: none; margin-top: 20px; width: 100%;">
                        Start Game (Min 2 players)
                    </button>
                    <button onclick="leaveRoom()" style="margin-top: 10px; width: 100%;">Leave Room</button>
                </div>
            </div>
        </div>

        <!-- Game Board -->
        <div id="game-board" class="game-board">
            <div class="game-header">
                <div class="turn-indicator" id="turn-indicator">Current Turn: Player 1</div>
                <div class="phase-indicator" id="phase-indicator">Beginning Phase</div>
                <div class="my-turn-indicator" id="my-turn-indicator">NOT YOUR TURN</div>
                <div>Unicorns to Win: <span id="win-condition">7</span></div>
            </div>

            <div class="game-area">
                <div class="deck-area">
                    <div class="deck" id="draw-deck" onclick="drawCard()">
                        <div>Draw Deck</div>
                        <div id="deck-count">0 cards</div>
                    </div>
                    <div class="discard-pile">
                        <div>Discard Pile</div>
                        <div id="discard-count">0 cards</div>
                    </div>
                    <div class="game-log">
                        <h4>Game Log:</h4>
                        <div id="game-log-entries"></div>
                    </div>
                </div>

                <div class="main-area">
                    <div class="opponents-area" id="opponents-area">
                        <!-- Opponent stables will be dynamically added here -->
                    </div>

                    <div class="my-stable" id="my-stable-area">
                        <div class="stable-header">My Stable (<span id="my-unicorn-count">0</span> Unicorns)</div>
                        <div class="stable-cards" id="my-stable-cards"></div>
                    </div>

                    <div class="my-hand">
                        <div class="stable-header">My Hand (<span id="hand-count">0</span> cards)</div>
                        <div class="hand-cards" id="hand-cards"></div>
                    </div>
                </div>

                <div class="deck-area">
                    <h3>Game Info</h3>
                    <div style="margin-top: 10px; font-size: 0.9em;">
                        <p><strong>Turn Order:</strong></p>
                        <div id="turn-order"></div>
                        <p style="margin-top: 10px;"><strong>Phase:</strong></p>
                        <p id="current-phase-info">Beginning</p>
                        <p style="margin-top: 10px;"><strong>Actions:</strong></p>
                        <p id="actions-remaining">1 remaining</p>
                    </div>
                </div>
            </div>

            <div class="action-buttons">
                <button class="action-button" id="play-card-btn" onclick="playSelectedCard()">Play Card</button>
                <button class="action-button" id="skip-phase-btn" onclick="skipPhase()">Skip Phase</button>
                <button class="action-button" id="end-turn-btn" onclick="endTurn()">End Turn</button>
            </div>
        </div>

        <!-- Target Selection Modal -->
        <div id="target-modal" class="modal">
            <div class="modal-content">
                <h2 id="modal-title">Select Target</h2>
                <div id="target-list" class="target-list"></div>
                <button onclick="closeTargetModal()" style="margin-top: 20px;">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Game State
        let gameState = {
            roomCode: null,
            players: [],
            currentPlayer: null,
            isHost: false,
            myPlayerId: null,
            gameStarted: false,
            currentTurnIndex: 0,
            currentPhase: 'beginning',
            deck: [],
            discardPile: [],
            hands: {},
            stables: {},
            upgrades: {},
            downgrades: {},
            selectedCard: null,
            actionsRemaining: 1,
            hasDrawn: false,
            hasPlayedThisTurn: false,
            winCondition: 7,
            turnNumber: 0
        };

        // Card Definitions
        const cardDefinitions = {
            babyUnicorns: [
                {id: 'baby1', type: 'baby', name: 'Baby Unicorn', description: 'Basic baby unicorn'},
                {id: 'baby2', type: 'baby', name: 'Baby Unicorn', description: 'Basic baby unicorn'},
                {id: 'baby3', type: 'baby', name: 'Baby Unicorn', description: 'Basic baby unicorn'},
                {id: 'baby4', type: 'baby', name: 'Baby Unicorn', description: 'Basic baby unicorn'},
                {id: 'baby5', type: 'baby', name: 'Baby Unicorn', description: 'Basic baby unicorn'},
                {id: 'baby6', type: 'baby', name: 'Baby Unicorn', description: 'Basic baby unicorn'},
                {id: 'baby7', type: 'baby', name: 'Baby Unicorn', description: 'Basic baby unicorn'},
                {id: 'baby8', type: 'baby', name: 'Baby Unicorn', description: 'Basic baby unicorn'},
                {id: 'baby9', type: 'baby', name: 'Baby Unicorn', description: 'Basic baby unicorn'},
                {id: 'baby10', type: 'baby', name: 'Baby Unicorn', description: 'Basic baby unicorn'},
                {id: 'baby11', type: 'baby', name: 'Baby Unicorn', description: 'Basic baby unicorn'},
                {id: 'baby12', type: 'baby', name: 'Baby Unicorn', description: 'Basic baby unicorn'}
            ],
            basicUnicorns: [
                {id: 'basic1', type: 'unicorn', name: 'Basic Unicorn', description: 'Boring. Ordinary.'},
                {id: 'basic2', type: 'unicorn', name: 'Basic Unicorn', description: 'Boring. Ordinary.'},
                {id: 'basic3', type: 'unicorn', name: 'Basic Unicorn', description: 'Boring. Ordinary.'},
                {id: 'basic4', type: 'unicorn', name: 'Basic Unicorn', description: 'Boring. Ordinary.'},
                {id: 'basic5', type: 'unicorn', name: 'Basic Unicorn', description: 'Boring. Ordinary.'},
                {id: 'basic6', type: 'unicorn', name: 'Basic Unicorn', description: 'Boring. Ordinary.'},
                {id: 'basic7', type: 'unicorn', name: 'Basic Unicorn', description: 'Boring. Ordinary.'},
                {id: 'basic8', type: 'unicorn', name: 'Basic Unicorn', description: 'Boring. Ordinary.'},
                {id: 'basic9', type: 'unicorn', name: 'Basic Unicorn', description: 'Boring. Ordinary.'},
                {id: 'basic10', type: 'unicorn', name: 'Basic Unicorn', description: 'Boring. Ordinary.'},
                {id: 'basic11', type: 'unicorn', name: 'Basic Unicorn', description: 'Boring. Ordinary.'},
                {id: 'basic12', type: 'unicorn', name: 'Basic Unicorn', description: 'Boring. Ordinary.'},
                {id: 'basic13', type: 'unicorn', name: 'Basic Unicorn', description: 'Boring. Ordinary.'},
                {id: 'basic14', type: 'unicorn', name: 'Basic Unicorn', description: 'Boring. Ordinary.'},
                {id: 'basic15', type: 'unicorn', name: 'Basic Unicorn', description: 'Boring. Ordinary.'}
            ],
            magicalUnicorns: [
                {id: 'magical1', type: 'unicorn', name: 'Rainbow Unicorn', description: 'When this enters your stable, bring a Basic Unicorn from your hand directly into your stable.', effect: 'onEnter'},
                {id: 'magical2', type: 'unicorn', name: 'Zombie Unicorn', description: 'If this is in your stable when any unicorn is destroyed, you may return it to your hand instead.', effect: 'persistent'},
                {id: 'magical3', type: 'unicorn', name: 'Extremely Destructive Unicorn', description: 'When this enters your stable, each player must SACRIFICE a unicorn.', effect: 'onEnter'},
                {id: 'magical4', type: 'unicorn', name: 'Magical Kittencorn', description: 'This card cannot be destroyed by magic cards.', effect: 'persistent'},
                {id: 'magical5', type: 'unicorn', name: 'Stabby Unicorn', description: 'When this enters your stable, you may destroy an upgrade or downgrade.', effect: 'onEnter'},
                {id: 'magical6', type: 'unicorn', name: 'Puppicorn', description: 'When this enters your stable, draw a card.', effect: 'onEnter'},
                {id: 'magical7', type: 'unicorn', name: 'Rhinocorn', description: 'When this enters your stable, you may destroy a unicorn.', effect: 'onEnter'},
                {id: 'magical8', type: 'unicorn', name: 'Extremely Fertile Unicorn', description: 'If this is in your stable at the beginning of your turn, you may discard a card to bring a baby unicorn from the nursery into your stable.', effect: 'beginningOfTurn'},
                {id: 'magical9', type: 'unicorn', name: 'Llamacorn', description: 'When this enters your stable, each player must DISCARD a card.', effect: 'onEnter'},
                {id: 'magical10', type: 'unicorn', name: 'Americorn', description: 'All your unicorns count as 2 unicorns.', effect: 'persistent'},
                {id: 'magical11', type: 'unicorn', name: 'Ginormous Unicorn', description: 'This counts as 2 unicorns. You cannot play any Instant cards.', effect: 'persistent'},
                {id: 'magical12', type: 'unicorn', name: 'Seductive Unicorn', description: 'When this enters your stable, STEAL a unicorn. Return it at the end of your turn.', effect: 'onEnter'},
                {id: 'magical13', type: 'unicorn', name: 'Angel Unicorn', description: 'If this is in your stable when a unicorn is destroyed, you may DRAW a card.', effect: 'persistent'},
                {id: 'magical14', type: 'unicorn', name: 'Queen Bee Unicorn', description: 'Basic unicorns cannot enter any stable.', effect: 'persistent'},
                {id: 'magical15', type: 'unicorn', name: 'Greedy Flying Unicorn', description: 'When this enters your stable, DRAW a card. If this is sacrificed or destroyed, return it to your hand.', effect: 'onEnter'}
            ],
            magicCards: [
                {id: 'magic1', type: 'magic', name: 'Unicorn Poison', description: 'DESTROY a unicorn.', effect: 'destroy'},
                {id: 'magic2', type: 'magic', name: 'Back Kick', description: 'Return a unicorn to its owner\'s hand.', effect: 'return'},
                {id: 'magic3', type: 'magic', name: 'Change of Luck', description: 'DRAW 2 cards and DISCARD 3 cards.', effect: 'draw'},
                {id: 'magic4', type: 'magic', name: 'Glitter Tornado', description: 'Return all cards in YOUR hand to the deck. Shuffle. DRAW the same number of cards.', effect: 'shuffle'},
                {id: 'magic5', type: 'magic', name: 'Unicorn Swap', description: 'Move a unicorn in your stable to any other stable. Move a unicorn from that stable to your stable.', effect: 'swap'},
                {id: 'magic6', type: 'magic', name: 'Re-Target', description: 'Move an Upgrade or Downgrade from one player to another.', effect: 'move'},
                {id: 'magic7', type: 'magic', name: 'Unfair Bargain', description: 'Trade hands with another player.', effect: 'trade'},
                {id: 'magic8', type: 'magic', name: 'Two-For-One', description: 'SACRIFICE a unicorn. DESTROY 2 unicorns.', effect: 'sacrifice'},
                {id: 'magic9', type: 'magic', name: 'Unicorn Shrinkray', description: 'Choose any player. Unicorns in that player\'s stable count as baby unicorns until your next turn.', effect: 'shrink'},
                {id: 'magic10', type: 'magic', name: 'Targeted Destruction', description: 'DESTROY an Upgrade or Downgrade.', effect: 'destroyUpgrade'},
                {id: 'magic11', type: 'magic', name: 'Mystical Vortex', description: 'Shuffle EVERYONE\'s hand into the deck. Each player DRAWS 3 cards.', effect: 'vortex'},
                {id: 'magic12', type: 'magic', name: 'Good Deal', description: 'DRAW 3 cards and DISCARD 1 card.', effect: 'goodDeal'},
                {id: 'magic13', type: 'magic', name: 'Shake Up', description: 'Shuffle your hand into the deck. DRAW 5 cards.', effect: 'shakeUp'},
                {id: 'magic14', type: 'magic', name: 'Blatant Thievery', description: 'Look at another player\'s hand. Choose a card and add it to your hand.', effect: 'steal'}
            ],
            instantCards: [
                {id: 'instant1', type: 'instant', name: 'Neigh', description: 'Play when any player plays a card. Stop that card and send it to the discard pile.', effect: 'counter'},
                {id: 'instant2', type: 'instant', name: 'Neigh', description: 'Play when any player plays a card. Stop that card and send it to the discard pile.', effect: 'counter'},
                {id: 'instant3', type: 'instant', name: 'Neigh', description: 'Play when any player plays a card. Stop that card and send it to the discard pile.', effect: 'counter'},
                {id: 'instant4', type: 'instant', name: 'Neigh', description: 'Play when any player plays a card. Stop that card and send it to the discard pile.', effect: 'counter'},
                {id: 'instant5', type: 'instant', name: 'Neigh', description: 'Play when any player plays a card. Stop that card and send it to the discard pile.', effect: 'counter'},
                {id: 'instant6', type: 'instant', name: 'Neigh', description: 'Play when any player plays a card. Stop that card and send it to the discard pile.', effect: 'counter'},
                {id: 'instant7', type: 'instant', name: 'Neigh', description: 'Play when any player plays a card. Stop that card and send it to the discard pile.', effect: 'counter'},
                {id: 'instant8', type: 'instant', name: 'Neigh', description: 'Play when any player plays a card. Stop that card and send it to the discard pile.', effect: 'counter'},
                {id: 'instant9', type: 'instant', name: 'Super Neigh', description: 'This cannot be Neighed. Play when any player plays a card. Stop that card and send it to the discard pile.', effect: 'superCounter'},
                {id: 'instant10', type: 'instant', name: 'Yay', description: 'Play when another player tries to play a card. That card is brought into YOUR stable instead.', effect: 'steal'}
            ],
            upgradeCards: [
                {id: 'upgrade1', type: 'upgrade', name: 'Double Dutch', description: 'You may play 2 cards during your Action phase.', effect: 'doubleAction'},
                {id: 'upgrade2', type: 'upgrade', name: 'Glitter Bomb', description: 'When you play a unicorn, you may DESTROY a card.', effect: 'destroyOnPlay'},
                {id: 'upgrade3', type: 'upgrade', name: 'Rainbow Aura', description: 'Your unicorns cannot be destroyed.', effect: 'protection'},
                {id: 'upgrade4', type: 'upgrade', name: 'Summoning Ritual', description: 'You may DRAW an extra card during your Draw phase.', effect: 'extraDraw'},
                {id: 'upgrade5', type: 'upgrade', name: 'Unicorn Lasso', description: 'When you play an Upgrade, you may STEAL a unicorn until end of turn.', effect: 'steal'},
                {id: 'upgrade6', type: 'upgrade', name: 'Extra Tail', description: 'You may DRAW an extra card when you play a unicorn.', effect: 'drawOnUnicorn'},
                {id: 'upgrade7', type: 'upgrade', name: 'Caffeine Overload', description: 'Your hand limit is 10 cards.', effect: 'handLimit'}
            ],
            downgradeCards: [
                {id: 'downgrade1', type: 'downgrade', name: 'Barbed Wire', description: 'You cannot play Upgrade cards.', effect: 'noUpgrades'},
                {id: 'downgrade2', type: 'downgrade', name: 'Broken Stable', description: 'You cannot have more than 5 unicorns in your stable.', effect: 'limitUnicorns'},
                {id: 'downgrade3', type: 'downgrade', name: 'Blinding Light', description: 'Your unicorn cards count as Basic Unicorns.', effect: 'makeBasic'},
                {id: 'downgrade4', type: 'downgrade', name: 'Tiny Stable', description: 'If you have 4 or more unicorns in your stable, you cannot play unicorns.', effect: 'tinyStable'},
                {id: 'downgrade5', type: 'downgrade', name: 'Slowdown', description: 'You cannot play Instant cards.', effect: 'noInstant'},
                {id: 'downgrade6', type: 'downgrade', name: 'Nanny Cam', description: 'Your hand is visible to all players.', effect: 'visibleHand'},
                {id: 'downgrade7', type: 'downgrade', name: 'Sadistic Ritual', description: 'At the beginning of your turn, SACRIFICE a unicorn. Draw a card.', effect: 'sacrifice'}
            ]
        };

        // Initialize Local Storage for multiplayer simulation
        function initLocalMultiplayer() {
            if (!localStorage.getItem('unstableRooms')) {
                localStorage.setItem('unstableRooms', JSON.stringify({}));
            }
        }

        // Generate random 5-digit room code
        function generateRoomCode() {
            return Math.floor(10000 + Math.random() * 90000).toString();
        }

        // Create Room
        function createRoom() {
            const playerName = prompt("Enter your name:");
            if (!playerName) return;

            const roomCode = generateRoomCode();
            const playerId = 'player_' + Date.now().toString();
            
            gameState.roomCode = roomCode;
            gameState.isHost = true;
            gameState.myPlayerId = playerId;
            gameState.currentPlayer = {
                id: playerId,
                name: playerName,
                isHost: true
            };
            
            const roomData = {
                code: roomCode,
                host: playerId,
                players: [{
                    id: playerId,
                    name: playerName,
                    isHost: true
                }],
                gameStarted: false,
                gameState: null
            };
            
            const rooms = JSON.parse(localStorage.getItem('unstableRooms'));
            rooms[roomCode] = roomData;
            localStorage.setItem('unstableRooms', JSON.stringify(rooms));
            
            showRoomLobby();
            startRoomPolling();
        }

        // Show join room interface
        function showJoinRoom() {
            document.getElementById('initial-menu').style.display = 'none';
            document.getElementById('join-room').style.display = 'block';
        }

        // Join Room
        function joinRoom() {
            const roomCode = document.getElementById('room-code-input').value;
            const playerName = document.getElementById('player-name-input').value;
            
            if (roomCode.length !== 5 || !playerName) {
                alert('Please enter a valid 5-digit room code and your name');
                return;
            }
            
            const rooms = JSON.parse(localStorage.getItem('unstableRooms'));
            if (!rooms[roomCode]) {
                alert('Room not found!');
                return;
            }
            
            if (rooms[roomCode].gameStarted) {
                alert('Game already in progress!');
                return;
            }
            
            const playerId = 'player_' + Date.now().toString();
            const newPlayer = {
                id: playerId,
                name: playerName,
                isHost: false
            };
            
            rooms[roomCode].players.push(newPlayer);
            localStorage.setItem('unstableRooms', JSON.stringify(rooms));
            
            gameState.roomCode = roomCode;
            gameState.myPlayerId = playerId;
            gameState.currentPlayer = newPlayer;
            gameState.isHost = false;
            
            showRoomLobby();
            startRoomPolling();
        }

        // Back to menu
        function backToMenu() {
            document.getElementById('join-room').style.display = 'none';
            document.getElementById('initial-menu').style.display = 'block';
        }

        // Show room lobby
        function showRoomLobby() {
            document.getElementById('initial-menu').style.display = 'none';
            document.getElementById('join-room').style.display = 'none';
            document.getElementById('room-lobby').style.display = 'block';
            
            document.getElementById('room-code-display').textContent = gameState.roomCode;
            
            if (gameState.isHost) {
                document.getElementById('start-game-btn').style.display = 'block';
            }
            
            updatePlayersList();
        }

        // Update players list
        function updatePlayersList() {
            const rooms = JSON.parse(localStorage.getItem('unstableRooms'));
            if (!rooms[gameState.roomCode]) return;
            
            const players = rooms[gameState.roomCode].players;
            gameState.players = players;
            
            const listElement = document.getElementById('players-list');
            listElement.innerHTML = '';
            
            players.forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-item' + (player.isHost ? ' host' : '');
                if (player.id === gameState.myPlayerId) {
                    playerDiv.className += ' current';
                }
                playerDiv.textContent = player.name + (player.id === gameState.myPlayerId ? ' (You)' : '');
                listElement.appendChild(playerDiv);
            });
            
            // Enable start button if enough players
            if (gameState.isHost) {
                const startBtn = document.getElementById('start-game-btn');
                startBtn.disabled = players.length < 2;
                startBtn.textContent = players.length < 2 ? 
                    'Waiting for players...' : 
                    `Start Game (${players.length} players)`;
            }
        }

        // Room polling for updates
        let pollingInterval;
        function startRoomPolling() {
            pollingInterval = setInterval(() => {
                const rooms = JSON.parse(localStorage.getItem('unstableRooms'));
                if (!rooms[gameState.roomCode]) {
                    clearInterval(pollingInterval);
                    alert('Room has been closed');
                    location.reload();
                    return;
                }
                
                const room = rooms[gameState.roomCode];
                
                // Update players list
                if (room.players.length !== gameState.players.length) {
                    updatePlayersList();
                }
                
                // Check if game started
                if (room.gameStarted && !gameState.gameStarted) {
                    gameState = {...room.gameState};
                    gameState.myPlayerId = gameState.myPlayerId || room.gameState.myPlayerId;
                    gameState.gameStarted = true;
                    initializeGame();
                }
                
                // Update game state if in game
                if (room.gameStarted && room.gameState) {
                    const latestState = room.gameState;
                    if (latestState.lastUpdate && latestState.lastUpdate !== gameState.lastUpdate) {
                        const myId = gameState.myPlayerId;
                        const isMyHost = gameState.isHost;
                        gameState = {...latestState};
                        gameState.myPlayerId = myId;
                        gameState.isHost = isMyHost;
                        updateGameBoard();
                    }
                }
            }, 500);
        }

        // Leave room
        function leaveRoom() {
            clearInterval(pollingInterval);
            
            const rooms = JSON.parse(localStorage.getItem('unstableRooms'));
            if (rooms[gameState.roomCode]) {
                rooms[gameState.roomCode].players = rooms[gameState.roomCode].players.filter(
                    p => p.id !== gameState.myPlayerId
                );
                
                if (rooms[gameState.roomCode].players.length === 0) {
                    delete rooms[gameState.roomCode];
                } else if (gameState.isHost) {
                    // Transfer host to next player
                    rooms[gameState.roomCode].players[0].isHost = true;
                    rooms[gameState.roomCode].host = rooms[gameState.roomCode].players[0].id;
                }
                
                localStorage.setItem('unstableRooms', JSON.stringify(rooms));
            }
            
            location.reload();
        }

        // Start Game
        function startGame() {
            if (!gameState.isHost) return;
            if (gameState.players.length < 2) {
                alert('Need at least 2 players to start');
                return;
            }
            
            // Initialize game state
            initializeGameState();
            
            const rooms = JSON.parse(localStorage.getItem('unstableRooms'));
            rooms[gameState.roomCode].gameStarted = true;
            rooms[gameState.roomCode].gameState = gameState;
            localStorage.setItem('unstableRooms', JSON.stringify(rooms));
            
            gameState.gameStarted = true;
            initializeGame();
        }

        // Initialize game state
        function initializeGameState() {
            // Set win condition based on player count
            gameState.winCondition = gameState.players.length <= 5 ? 7 : 6;
            
            // Create and shuffle deck
            const deck = [];
            Object.values(cardDefinitions).forEach(category => {
                if (Array.isArray(category)) {
                    category.forEach(card => {
                        if (card.type !== 'baby') {
                            deck.push({...card});
                        }
                    });
                }
            });
            
            // Shuffle deck
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            
            gameState.deck = deck;
            gameState.discardPile = [];
            
            // Initialize player hands and stables
            gameState.players.forEach((player, index) => {
                gameState.hands[player.id] = [];
                gameState.stables[player.id] = [];
                gameState.upgrades[player.id] = [];
                gameState.downgrades[player.id] = [];
                
                // Give each player a baby unicorn
                if (index < cardDefinitions.babyUnicorns.length) {
                    gameState.stables[player.id].push({
                        ...cardDefinitions.babyUnicorns[index],
                        owner: player.id
                    });
                }
                
                // Deal 5 cards to each player
                for (let i = 0; i < 5; i++) {
                    if (gameState.deck.length > 0) {
                        gameState.hands[player.id].push(gameState.deck.pop());
                    }
                }
            });
            
            gameState.currentTurnIndex = 0;
            gameState.currentPhase = 'beginning';
            gameState.hasDrawn = false;
            gameState.hasPlayedThisTurn = false;
            gameState.actionsRemaining = 1;
            gameState.turnNumber = 1;
            gameState.lastUpdate = Date.now();
        }

        // Initialize game board
        function initializeGame() {
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('game-board').style.display = 'block';
            
            document.getElementById('win-condition').textContent = gameState.winCondition;
            
            // Start the first turn properly
            if (gameState.turnNumber === 1 && gameState.currentPhase === 'beginning') {
                // Skip beginning phase for first turn
                gameState.currentPhase = 'action';
                gameState.actionsRemaining = 1;
                syncGameState();
            }
            
            updateGameBoard();
        }

        // Check if it's my turn
        function isMyTurn() {
            const currentPlayerId = gameState.players[gameState.currentTurnIndex]?.id;
            return currentPlayerId === gameState.myPlayerId;
        }

        // Update game board
        function updateGameBoard() {
            // Update turn indicator
            const currentPlayer = gameState.players[gameState.currentTurnIndex];
            if (!currentPlayer) return;
            
            document.getElementById('turn-indicator').textContent = 
                `Current Turn: ${currentPlayer.name}`;
            
            // Update my turn indicator
            const myTurnIndicator = document.getElementById('my-turn-indicator');
            if (isMyTurn()) {
                myTurnIndicator.textContent = 'YOUR TURN';
                myTurnIndicator.className = 'my-turn-indicator';
            } else {
                myTurnIndicator.textContent = 'NOT YOUR TURN';
                myTurnIndicator.className = 'my-turn-indicator not-my-turn';
            }
            
            // Update phase
            const phaseNames = {
                'beginning': 'Beginning Phase',
                'draw': 'Draw Phase', 
                'action': 'Action Phase',
                'end': 'End Phase'
            };
            document.getElementById('phase-indicator').textContent = phaseNames[gameState.currentPhase];
            document.getElementById('current-phase-info').textContent = phaseNames[gameState.currentPhase];
            
            // Update deck and discard counts
            document.getElementById('deck-count').textContent = `${gameState.deck.length} cards`;
            document.getElementById('discard-count').textContent = `${gameState.discardPile.length} cards`;
            
            // Enable/disable draw deck based on phase and turn
            const drawDeck = document.getElementById('draw-deck');
            if (isMyTurn() && gameState.currentPhase === 'draw' && !gameState.hasDrawn) {
                drawDeck.classList.remove('disabled');
            } else {
                drawDeck.classList.add('disabled');
            }
            
            // Update turn order display
            const turnOrderDiv = document.getElementById('turn-order');
            turnOrderDiv.innerHTML = '';
            gameState.players.forEach((player, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.style.fontSize = '0.8em';
                playerDiv.style.padding = '2px';
                if (index === gameState.currentTurnIndex) {
                    playerDiv.style.fontWeight = 'bold';
                    playerDiv.style.color = '#28a745';
                }
                playerDiv.textContent = `${index + 1}. ${player.name}`;
                turnOrderDiv.appendChild(playerDiv);
            });
            
            // Update my hand
            const myHand = gameState.hands[gameState.myPlayerId] || [];
            const handContainer = document.getElementById('hand-cards');
            handContainer.innerHTML = '';
            document.getElementById('hand-count').textContent = myHand.length;
            
            myHand.forEach(card => {
                const cardElement = createCardElement(card);
                if (isMyTurn()) {
                    cardElement.onclick = () => selectCard(card);
                }
                handContainer.appendChild(cardElement);
            });
            
            // Update my stable
            const myStable = gameState.stables[gameState.myPlayerId] || [];
            const stableContainer = document.getElementById('my-stable-cards');
            stableContainer.innerHTML = '';
            
            // Add unicorns
            myStable.forEach(card => {
                const cardElement = createCardElement(card);
                stableContainer.appendChild(cardElement);
            });
            
            // Add upgrades
            const myUpgrades = gameState.upgrades[gameState.myPlayerId] || [];
            myUpgrades.forEach(card => {
                const cardElement = createCardElement(card);
                stableContainer.appendChild(cardElement);
            });
            
            // Add downgrades
            const myDowngrades = gameState.downgrades[gameState.myPlayerId] || [];
            myDowngrades.forEach(card => {
                const cardElement = createCardElement(card);
                stableContainer.appendChild(cardElement);
            });
            
            const unicornCount = myStable.filter(c => 
                c.type === 'unicorn' || c.type === 'baby'
            ).length;
            document.getElementById('my-unicorn-count').textContent = unicornCount;
            
            // Highlight my stable if it's my turn
            const myStableArea = document.getElementById('my-stable-area');
            if (isMyTurn()) {
                myStableArea.classList.add('current-player');
            } else {
                myStableArea.classList.remove('current-player');
            }
            
            // Update opponents area
            const opponentsArea = document.getElementById('opponents-area');
            opponentsArea.innerHTML = '';
            
            gameState.players.forEach(player => {
                if (player.id !== gameState.myPlayerId) {
                    const opponentDiv = document.createElement('div');
                    opponentDiv.className = 'opponent-stable';
                    if (gameState.players[gameState.currentTurnIndex].id === player.id) {
                        opponentDiv.classList.add('current-player');
                    }
                    
                    const stable = gameState.stables[player.id] || [];
                    const unicornCount = stable.filter(c => 
                        c.type === 'unicorn' || c.type === 'baby'
                    ).length;
                    
                    const handCount = gameState.hands[player.id]?.length || 0;
                    
                    opponentDiv.innerHTML = `
                        <div class="stable-header">${player.name}'s Stable (${unicornCount} Unicorns, ${handCount} cards in hand)</div>
                        <div class="stable-cards" id="opponent-${player.id}-stable"></div>
                    `;
                    
                    opponentsArea.appendChild(opponentDiv);
                    
                    const opponentStableContainer = document.getElementById(`opponent-${player.id}-stable`);
                    
                    // Add unicorns
                    stable.forEach(card => {
                        const cardElement = createCardElement(card);
                        opponentStableContainer.appendChild(cardElement);
                    });
                    
                    // Add upgrades
                    const upgrades = gameState.upgrades[player.id] || [];
                    upgrades.forEach(card => {
                        const cardElement = createCardElement(card);
                        opponentStableContainer.appendChild(cardElement);
                    });
                    
                    // Add downgrades
                    const downgrades = gameState.downgrades[player.id] || [];
                    downgrades.forEach(card => {
                        const cardElement = createCardElement(card);
                        opponentStableContainer.appendChild(cardElement);
                    });
                }
            });
            
            // Update actions remaining
            document.getElementById('actions-remaining').textContent = 
                `${gameState.actionsRemaining} remaining`;
            
            // Update action buttons
            const playBtn = document.getElementById('play-card-btn');
            const skipBtn = document.getElementById('skip-phase-btn');
            const endBtn = document.getElementById('end-turn-btn');
            
            if (isMyTurn()) {
                playBtn.disabled = gameState.currentPhase !== 'action' || gameState.actionsRemaining <= 0;
                skipBtn.disabled = false;
                endBtn.disabled = false;
                skipBtn.textContent = gameState.currentPhase === 'draw' ? 'Skip Draw' : 'Skip Phase';
            } else {
                playBtn.disabled = true;
                skipBtn.disabled = true;
                endBtn.disabled = true;
            }
            
            // Check for winner
            checkWinCondition();
        }

        // Create card element
        function createCardElement(card) {
            const cardDiv = document.createElement('div');
            cardDiv.className = `card ${card.type}`;
            if (gameState.selectedCard && gameState.selectedCard.id === card.id) {
                cardDiv.className += ' selected';
            }
            
            cardDiv.innerHTML = `
                <div class="card-type">${card.type}</div>
                <div class="card-name">${card.name}</div>
                <div class="card-description">${card.description}</div>
            `;
            
            return cardDiv;
        }

        // Select card
        function selectCard(card) {
            if (!isMyTurn()) {
                addGameLog("It's not your turn!", true);
                return;
            }
            
            if (gameState.currentPhase !== 'action') {
                addGameLog("You can only play cards during the action phase!", true);
                return;
            }
            
            if (gameState.selectedCard && gameState.selectedCard.id === card.id) {
                gameState.selectedCard = null;
            } else {
                gameState.selectedCard = card;
            }
            updateGameBoard();
        }

        // Skip current phase
        function skipPhase() {
            if (!isMyTurn()) {
                addGameLog("It's not your turn!", true);
                return;
            }
            
            if (gameState.currentPhase === 'beginning') {
                gameState.currentPhase = 'draw';
                addGameLog("Skipped beginning phase");
            } else if (gameState.currentPhase === 'draw') {
                gameState.currentPhase = 'action';
                addGameLog("Skipped draw phase");
            } else if (gameState.currentPhase === 'action') {
                endTurn();
                return;
            }
            
            syncGameState();
            updateGameBoard();
        }

        // Play selected card
        function playSelectedCard() {
            if (!gameState.selectedCard) {
                addGameLog("No card selected!", true);
                return;
            }
            
            if (!isMyTurn()) {
                addGameLog("It's not your turn!", true);
                return;
            }
            
            if (gameState.currentPhase !== 'action') {
                addGameLog("You can only play cards during the action phase!", true);
                return;
            }
            
            if (gameState.actionsRemaining <= 0) {
                addGameLog("No actions remaining!", true);
                return;
            }
            
            const card = gameState.selectedCard;
            
            // Check for downgrades that might prevent playing
            const myDowngrades = gameState.downgrades[gameState.myPlayerId] || [];
            for (let downgrade of myDowngrades) {
                if (downgrade.effect === 'noUpgrades' && card.type === 'upgrade') {
                    addGameLog("Barbed Wire prevents you from playing upgrades!", true);
                    return;
                }
                if (downgrade.effect === 'tinyStable' && 
                    (card.type === 'unicorn' || card.type === 'baby')) {
                    const unicornCount = gameState.stables[gameState.myPlayerId].filter(
                        c => c.type === 'unicorn' || c.type === 'baby'
                    ).length;
                    if (unicornCount >= 4) {
                        addGameLog("Tiny Stable prevents you from playing more unicorns!", true);
                        return;
                    }
                }
                if (downgrade.effect === 'noInstant' && card.type === 'instant') {
                    addGameLog("Slowdown prevents you from playing instant cards!", true);
                    return;
                }
            }
            
            // Remove card from hand first
            const hand = gameState.hands[gameState.myPlayerId];
            const index = hand.findIndex(c => c.id === card.id);
            if (index > -1) {
                hand.splice(index, 1);
            }
            
            // Play the card based on type
            let cardPlayed = true;
            switch(card.type) {
                case 'unicorn':
                case 'baby':
                    playUnicorn(card);
                    break;
                case 'magic':
                    playMagicCard(card);
                    break;
                case 'instant':
                    addGameLog("Instant cards can only be played in response to other cards!", true);
                    hand.push(card); // Put it back
                    cardPlayed = false;
                    break;
                case 'upgrade':
                    playUpgrade(card);
                    break;
                case 'downgrade':
                    playDowngrade(card);
                    break;
            }
            
            if (cardPlayed) {
                gameState.selectedCard = null;
                gameState.actionsRemaining--;
                gameState.hasPlayedThisTurn = true;
                
                syncGameState();
                updateGameBoard();
            }
        }

        // Play unicorn card
        function playUnicorn(card) {
            gameState.stables[gameState.myPlayerId].push(card);
            const playerName = gameState.players.find(p => p.id === gameState.myPlayerId).name;
            addGameLog(`${playerName} played ${card.name}`);
            
            // Handle enter effects
            if (card.effect === 'onEnter') {
                handleUnicornEffect(card);
            }
        }

        // Play magic card
        function playMagicCard(card) {
            const playerName = gameState.players.find(p => p.id === gameState.myPlayerId).name;
            addGameLog(`${playerName} played ${card.name}`);
            
            handleMagicEffect(card);
            gameState.discardPile.push(card);
        }

        // Handle magic card effects
        function handleMagicEffect(card) {
            switch(card.effect) {
                case 'destroy':
                    selectTargetUnicorn('destroy');
                    break;
                case 'return':
                    selectTargetUnicorn('return');
                    break;
                case 'draw':
                    // Draw 2 cards
                    for (let i = 0; i < 2; i++) {
                        drawCardFromDeck(gameState.myPlayerId);
                    }
                    // Force discard 3
                    // TODO: Implement discard selection
                    addGameLog("You must discard 3 cards (not yet implemented)");
                    break;
                case 'goodDeal':
                    // Draw 3 cards
                    for (let i = 0; i < 3; i++) {
                        drawCardFromDeck(gameState.myPlayerId);
                    }
                    // TODO: Force discard 1
                    addGameLog("You must discard 1 card (not yet implemented)");
                    break;
                case 'shuffle':
                case 'shakeUp':
                    // Return hand to deck and shuffle
                    const hand = gameState.hands[gameState.myPlayerId];
                    gameState.deck.push(...hand);
                    gameState.hands[gameState.myPlayerId] = [];
                    shuffleDeck();
                    // Draw cards
                    const drawCount = card.effect === 'shuffle' ? hand.length : 5;
                    for (let i = 0; i < drawCount; i++) {
                        drawCardFromDeck(gameState.myPlayerId);
                    }
                    break;
                case 'swap':
                    // TODO: Implement unicorn swap
                    addGameLog("Unicorn swap not yet implemented");
                    break;
                                case 'destroyUpgrade':
                    selectTargetUpgradeDowngrade('destroy');
                    break;
                case 'move':
                    selectTargetUpgradeDowngrade('move');
                    break;
                case 'trade':
                    selectTargetPlayer((targetId) => {
                        const myHand = gameState.hands[gameState.myPlayerId];
                        const targetHand = gameState.hands[targetId];
                        gameState.hands[gameState.myPlayerId] = targetHand;
                        gameState.hands[targetId] = myHand;
                        addGameLog("Traded hands with opponent");
                        syncGameState();
                        updateGameBoard();
                    });
                    break;
                case 'sacrifice':
                    // TODO: Implement Two-For-One
                    addGameLog("Two-For-One not yet implemented");
                    break;
                case 'vortex':
                    // Shuffle everyone's hand into deck
                    gameState.players.forEach(player => {
                        const hand = gameState.hands[player.id] || [];
                        gameState.deck.push(...hand);
                        gameState.hands[player.id] = [];
                    });
                    shuffleDeck();
                    // Each player draws 3
                    gameState.players.forEach(player => {
                        for (let i = 0; i < 3; i++) {
                            drawCardFromDeck(player.id);
                        }
                    });
                    break;
                case 'steal':
                    // TODO: Implement Blatant Thievery
                    addGameLog("Card stealing not yet implemented");
                    break;
            }
        }

        // Play upgrade card
        function playUpgrade(card) {
            gameState.upgrades[gameState.myPlayerId].push(card);
            const playerName = gameState.players.find(p => p.id === gameState.myPlayerId).name;
            addGameLog(`${playerName} played upgrade: ${card.name}`);
            
            // Apply upgrade effects
            if (card.effect === 'doubleAction' && gameState.actionsRemaining === 1) {
                gameState.actionsRemaining = 2;
                addGameLog("Double Dutch grants an extra action!");
            }
        }

        // Play downgrade card
        function playDowngrade(card) {
            // Select target player
            const modal = document.getElementById('target-modal');
            const targetList = document.getElementById('target-list');
            document.getElementById('modal-title').textContent = 'Select player for downgrade';
            targetList.innerHTML = '';
            
            gameState.players.forEach(player => {
                if (player.id !== gameState.myPlayerId) {
                    const option = document.createElement('div');
                    option.className = 'target-option';
                    option.textContent = player.name;
                    option.onclick = () => {
                        gameState.downgrades[player.id].push(card);
                        const playerName = gameState.players.find(p => p.id === gameState.myPlayerId).name;
                        addGameLog(`${playerName} gave ${card.name} to ${player.name}`);
                        closeTargetModal();
                        syncGameState();
                        updateGameBoard();
                    };
                    targetList.appendChild(option);
                }
            });
            
            modal.style.display = 'flex';
        }

        // Handle unicorn effects
        function handleUnicornEffect(card) {
            switch(card.name) {
                case 'Rainbow Unicorn':
                    // Bring a basic unicorn from hand to stable
                    const basicInHand = gameState.hands[gameState.myPlayerId].find(
                        c => c.name === 'Basic Unicorn'
                    );
                    if (basicInHand) {
                        const index = gameState.hands[gameState.myPlayerId].findIndex(
                            c => c.id === basicInHand.id
                        );
                        gameState.hands[gameState.myPlayerId].splice(index, 1);
                        gameState.stables[gameState.myPlayerId].push(basicInHand);
                        addGameLog("Rainbow Unicorn brought a Basic Unicorn into play!");
                    }
                    break;
                case 'Puppicorn':
                case 'Greedy Flying Unicorn':
                    // Draw a card
                    drawCardFromDeck(gameState.myPlayerId);
                    addGameLog(`Drew a card from ${card.name}'s effect`);
                    break;
                case 'Rhinocorn':
                    selectTargetUnicorn('destroy');
                    break;
                case 'Stabby Unicorn':
                    selectTargetUpgradeDowngrade('destroy');
                    break;
                case 'Extremely Destructive Unicorn':
                    // Each player sacrifices a unicorn
                    addGameLog("Each player must sacrifice a unicorn!");
                    // TODO: Implement sacrifice selection for all players
                    break;
                case 'Llamacorn':
                    // Each player discards a card
                    addGameLog("Each player must discard a card!");
                    // TODO: Implement discard for all players
                    break;
                case 'Seductive Unicorn':
                    selectTargetUnicorn('steal');
                    break;
            }
        }

        // Draw card from deck
        function drawCardFromDeck(playerId) {
            if (gameState.deck.length === 0) {
                // Shuffle discard pile back into deck
                if (gameState.discardPile.length > 0) {
                    gameState.deck = [...gameState.discardPile];
                    gameState.discardPile = [];
                    shuffleDeck();
                    addGameLog("Shuffled discard pile into deck");
                }
            }
            
            if (gameState.deck.length > 0) {
                const card = gameState.deck.pop();
                gameState.hands[playerId].push(card);
                return true;
            }
            return false;
        }

        // Shuffle deck
        function shuffleDeck() {
            for (let i = gameState.deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [gameState.deck[i], gameState.deck[j]] = [gameState.deck[j], gameState.deck[i]];
            }
        }

        // Draw card (action)
        function drawCard() {
            if (!isMyTurn()) {
                addGameLog("It's not your turn!", true);
                return;
            }
            
            if (gameState.currentPhase !== 'draw') {
                addGameLog("You can only draw during the draw phase!", true);
                return;
            }
            
            if (gameState.hasDrawn) {
                addGameLog("You've already drawn this turn!", true);
                return;
            }
            
            let drawCount = 1;
            
            // Check for upgrades that affect drawing
            const myUpgrades = gameState.upgrades[gameState.myPlayerId] || [];
            if (myUpgrades.find(u => u.effect === 'extraDraw')) {
                drawCount = 2;
                addGameLog("Summoning Ritual lets you draw an extra card!");
            }
            
            for (let i = 0; i < drawCount; i++) {
                if (drawCardFromDeck(gameState.myPlayerId)) {
                    addGameLog("Drew a card");
                } else {
                    addGameLog("No cards left to draw!");
                }
            }
            
            gameState.hasDrawn = true;
            
            // Auto-advance to action phase
            gameState.currentPhase = 'action';
            addGameLog("Entering Action Phase");
            
            syncGameState();
            updateGameBoard();
        }

        // End turn
        function endTurn() {
            if (!isMyTurn()) {
                addGameLog("It's not your turn!", true);
                return;
            }
            
            // Check hand limit (7 cards max, or 10 with Caffeine Overload)
            const hand = gameState.hands[gameState.myPlayerId];
            const myUpgrades = gameState.upgrades[gameState.myPlayerId] || [];
            const handLimit = myUpgrades.find(u => u.effect === 'handLimit') ? 10 : 7;
            
            if (hand.length > handLimit) {
                addGameLog(`You must discard ${hand.length - handLimit} cards!`, true);
                // TODO: Implement discard selection
                return;
            }
            
            const currentPlayerName = gameState.players[gameState.currentTurnIndex].name;
            addGameLog(`${currentPlayerName} ended their turn`);
            
            // Move to next player
            gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.players.length;
            
            // If we've gone around, increment turn number
            if (gameState.currentTurnIndex === 0) {
                gameState.turnNumber++;
            }
            
            // Reset turn state
            gameState.currentPhase = 'beginning';
            gameState.actionsRemaining = 1;
            gameState.hasDrawn = false;
            gameState.hasPlayedThisTurn = false;
            
            // Check for Double Dutch upgrade for next player
            const nextPlayerId = gameState.players[gameState.currentTurnIndex].id;
            const nextUpgrades = gameState.upgrades[nextPlayerId] || [];
            if (nextUpgrades.find(u => u.effect === 'doubleAction')) {
                gameState.actionsRemaining = 2;
            }
            
            // Handle beginning of turn effects
            handleBeginningOfTurn(nextPlayerId);
            
            syncGameState();
            updateGameBoard();
        }

        // Handle beginning of turn effects
        function handleBeginningOfTurn(playerId) {
            const stable = gameState.stables[playerId] || [];
            const downgrades = gameState.downgrades[playerId] || [];
            
            // Check for Sadistic Ritual
            const sadisticRitual = downgrades.find(d => d.effect === 'sacrifice');
            if (sadisticRitual && stable.length > 0) {
                addGameLog(`${gameState.players.find(p => p.id === playerId).name} must sacrifice a unicorn due to Sadistic Ritual!`);
                // TODO: Implement forced sacrifice
            }
            
            // Auto-advance to draw phase after a short delay
            if (isMyTurn()) {
                setTimeout(() => {
                    gameState.currentPhase = 'draw';
                    addGameLog("Entering Draw Phase");
                    syncGameState();
                    updateGameBoard();
                }, 1000);
            }
        }

        // Select target unicorn
        function selectTargetUnicorn(action) {
            const allUnicorns = [];
            
            Object.keys(gameState.stables).forEach(playerId => {
                gameState.stables[playerId].forEach(unicorn => {
                    if (unicorn.type === 'unicorn' || unicorn.type === 'baby') {
                        const owner = gameState.players.find(p => p.id === playerId);
                        allUnicorns.push({
                            ...unicorn,
                            ownerId: playerId,
                            ownerName: owner ? owner.name : 'Unknown'
                        });
                    }
                });
            });
            
            if (allUnicorns.length === 0) {
                addGameLog("No unicorns to target!");
                return;
            }
            
            // Show target modal
            const modal = document.getElementById('target-modal');
            const targetList = document.getElementById('target-list');
            document.getElementById('modal-title').textContent = 
                action === 'destroy' ? 'Select unicorn to destroy' :
                action === 'return' ? 'Select unicorn to return' :
                action === 'steal' ? 'Select unicorn to steal' : 'Select target';
            targetList.innerHTML = '';
            
            allUnicorns.forEach(unicorn => {
                const option = document.createElement('div');
                option.className = 'target-option';
                option.textContent = `${unicorn.ownerName}'s ${unicorn.name}`;
                option.onclick = () => {
                    if (action === 'destroy') {
                        destroyUnicorn(unicorn.ownerId, unicorn.id);
                    } else if (action === 'return') {
                        returnUnicorn(unicorn.ownerId, unicorn.id);
                    } else if (action === 'steal') {
                        stealUnicorn(unicorn.ownerId, unicorn.id);
                    }
                    closeTargetModal();
                };
                targetList.appendChild(option);
            });
            
            modal.style.display = 'flex';
        }

        // Select target upgrade/downgrade
        function selectTargetUpgradeDowngrade(action) {
            const allCards = [];
            
            gameState.players.forEach(player => {
                const upgrades = gameState.upgrades[player.id] || [];
                const downgrades = gameState.downgrades[player.id] || [];
                
                upgrades.forEach(card => {
                    allCards.push({
                        ...card,
                        ownerId: player.id,
                        ownerName: player.name
                    });
                });
                
                downgrades.forEach(card => {
                    allCards.push({
                        ...card,
                        ownerId: player.id,
                        ownerName: player.name
                    });
                });
            });
            
            if (allCards.length === 0) {
                addGameLog("No upgrades or downgrades to target!");
                return;
            }
            
            const modal = document.getElementById('target-modal');
            const targetList = document.getElementById('target-list');
            document.getElementById('modal-title').textContent = 
                action === 'destroy' ? 'Select upgrade/downgrade to destroy' :
                action === 'move' ? 'Select upgrade/downgrade to move' : 'Select target';
            targetList.innerHTML = '';
            
            allCards.forEach(card => {
                const option = document.createElement('div');
                option.className = 'target-option';
                option.textContent = `${card.ownerName}'s ${card.name}`;
                option.onclick = () => {
                    if (action === 'destroy') {
                        destroyUpgradeDowngrade(card.ownerId, card.id, card.type);
                    } else if (action === 'move') {
                        // TODO: Implement move upgrade/downgrade
                        addGameLog("Moving upgrades/downgrades not yet implemented");
                    }
                    closeTargetModal();
                };
                targetList.appendChild(option);
            });
            
            modal.style.display = 'flex';
        }

        // Select target player
        function selectTargetPlayer(callback) {
            const modal = document.getElementById('target-modal');
            const targetList = document.getElementById('target-list');
            document.getElementById('modal-title').textContent = 'Select target player';
            targetList.innerHTML = '';
            
            gameState.players.forEach(player => {
                if (player.id !== gameState.myPlayerId) {
                    const option = document.createElement('div');
                    option.className = 'target-option';
                    option.textContent = player.name;
                    option.onclick = () => {
                        callback(player.id);
                        closeTargetModal();
                    };
                    targetList.appendChild(option);
                }
            });
            
            modal.style.display = 'flex';
        }

        // Close target modal
        function closeTargetModal() {
            document.getElementById('target-modal').style.display = 'none';
        }

        // Destroy unicorn
        function destroyUnicorn(ownerId, unicornId) {
            const stable = gameState.stables[ownerId];
            const index = stable.findIndex(c => c.id === unicornId);
            if (index > -1) {
                const destroyed = stable.splice(index, 1)[0];
                gameState.discardPile.push(destroyed);
                addGameLog(`Destroyed ${destroyed.name}`);
                
                // Check for Angel Unicorn effect
                gameState.players.forEach(player => {
                    const playerStable = gameState.stables[player.id] || [];
                    if (playerStable.find(c => c.name === 'Angel Unicorn')) {
                        drawCardFromDeck(player.id);
                        addGameLog(`${player.name} drew a card from Angel Unicorn's effect`);
                    }
                });
            }
            syncGameState();
            updateGameBoard();
        }

        // Return unicorn to hand
        function returnUnicorn(ownerId, unicornId) {
            const stable = gameState.stables[ownerId];
            const index = stable.findIndex(c => c.id === unicornId);
            if (index > -1) {
                const returned = stable.splice(index, 1)[0];
                gameState.hands[ownerId].push(returned);
                addGameLog(`Returned ${returned.name} to hand`);
            }
            syncGameState();
            updateGameBoard();
        }

        // Steal unicorn
        function stealUnicorn(ownerId, unicornId) {
            const stable = gameState.stables[ownerId];
            const index = stable.findIndex(c => c.id === unicornId);
            if (index > -1) {
                const stolen = stable.splice(index, 1)[0];
                gameState.stables[gameState.myPlayerId].push(stolen);
                addGameLog(`Stole ${stolen.name}!`);
                
                // TODO: Return at end of turn for Seductive Unicorn
            }
            syncGameState();
            updateGameBoard();
        }

        // Destroy upgrade/downgrade
        function destroyUpgradeDowngrade(ownerId, cardId, cardType) {
            const array = cardType === 'upgrade' ? gameState.upgrades[ownerId] : gameState.downgrades[ownerId];
            const index = array.findIndex(c => c.id === cardId);
            if (index > -1) {
                const destroyed = array.splice(index, 1)[0];
                gameState.discardPile.push(destroyed);
                addGameLog(`Destroyed ${destroyed.name}`);
            }
            syncGameState();
            updateGameBoard();
        }

        // Add game log entry
        function addGameLog(message, isError = false) {
            const logContainer = document.getElementById('game-log-entries');
            const entry = document.createElement('div');
            entry.className = 'log-entry' + (isError ? ' error' : '');
            const time = new Date().toLocaleTimeString();
            entry.textContent = `[${time}] ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // Check win condition
        function checkWinCondition() {
            for (let player of gameState.players) {
                const stable = gameState.stables[player.id] || [];
                let unicornCount = stable.filter(c => 
                    c.type === 'unicorn' || c.type === 'baby'
                ).length;
                
                // Check for special cards
                const hasAmericorn = stable.find(c => c.name === 'Americorn');
                const hasGinormous = stable.find(c => c.name === 'Ginormous Unicorn');
                
                if (hasAmericorn) {
                    unicornCount *= 2;
                }
                if (hasGinormous) {
                    unicornCount++; // Ginormous counts as 2, so add 1
                }
                
                if (unicornCount >= gameState.winCondition) {
                    showWinner(player);
                    return;
                }
            }
        }

        // Show winner
        function showWinner(player) {
            const winDiv = document.createElement('div');
            winDiv.className = 'win-screen';
            winDiv.innerHTML = `
                <h1>ðŸ¦„ Victory! ðŸ¦„</h1>
                <h2>${player.name} wins!</h2>
                <p>Congratulations on collecting ${gameState.winCondition} unicorns!</p>
                <button onclick="location.reload()">Play Again</button>
            `;
            document.body.appendChild(winDiv);
            
            clearInterval(pollingInterval);
        }

        // Sync game state to localStorage
        function syncGameState() {
            gameState.lastUpdate = Date.now();
            const rooms = JSON.parse(localStorage.getItem('unstableRooms'));
            if (rooms && rooms[gameState.roomCode]) {
                // Preserve each player's specific ID when syncing
                const preservedIds = {};
                if (rooms[gameState.roomCode].gameState) {
                    gameState.players.forEach(player => {
                        preservedIds[player.id] = player.id;
                    });
                }
                
                rooms[gameState.roomCode].gameState = {...gameState};
                localStorage.setItem('unstableRooms', JSON.stringify(rooms));
            }
        }

        // Initialize on page load
        initLocalMultiplayer();
    </script>
</body>
</html>
